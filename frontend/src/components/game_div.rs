use std::{ops::AddAssign, rc::Rc};

use crate::components::RegionDiv;
use common::{
    ai::mct::{make_move, Node},
    BoardIndex, BoardOutcome, BoardState, Game, MarkTileResult, Play, Player,
};
use gloo_console::log;
use tracing::instrument;
use web_time::{Duration, Instant};
use yew::{platform::spawn_local, prelude::*, virtual_dom::VNode};
use yew_agent::oneshot::{oneshot, use_oneshot_runner};

#[oneshot]
pub fn AITask(game: Game) -> Play {
    let timeout = Instant::now() + Duration::from_secs_f32(1.0);
    let should_terminate = move |node: &Node| {
        if Instant::now() > timeout {
            log!(format!(
                "average score: {:.3} over {} simulations",
                1.0 - (node.score() / node.n_visits() as f32),
                node.n_visits()
            ));
            log!(node
                .children()
                .map(|node| format!(
                    "{:.0} / {} = {:.3}",
                    node.score(),
                    node.n_visits(),
                    node.score() / node.n_visits() as f32
                ))
                .collect::<Vec<_>>());
            true
        } else {
            false
        }
    };

    make_move(game, should_terminate)
}

#[function_component(AIGameDiv)]
#[instrument]
pub(crate) fn ai_game_div() -> Html {
    let game = use_state(Game::new);
    let allow_switch = use_state(|| true);
    let counter = use_mut_ref(usize::default);
    let player = use_mut_ref(Player::default);
    let ai_task = use_oneshot_runner::<AITask>();

    let callback = {
        let state = game.clone();
        let player = Rc::clone(&player);
        let allow_switch = allow_switch.clone();
        let ai_agent = ai_task.clone();
        let counter = counter.clone();
        Callback::from(move |play| {
            let mut game = (*state).clone();

            // short-circuit if it's the AI's turn.
            if game.current_player != *player.borrow() {
                return;
            }

            if matches!(game.mark_tile(play), MarkTileResult::NoChange) {
                return;
            }
            state.set(game.clone());
            allow_switch.set(false);

            let state = state.clone();
            let ai_agent = ai_agent.clone();
            let id = *counter.borrow();
            let counter = counter.clone();
            spawn_local(async move {
                let play = ai_agent.run(game.clone()).await;
                if id == *counter.borrow() {
                    let result = game.mark_tile(play);
                    assert!(!matches!(result, MarkTileResult::NoChange), "move generated by AI should always be valid and should never result in no change.");
                    state.set(game);
                }
            });
        })
    };

    let game_state_text = match game.state {
        BoardState::InProgress => if game.current_player == *player.borrow() {
            "Your turn"
        } else {
            "AI's turn"
        }
        .to_owned(),
        BoardState::Complete(BoardOutcome::Draw) => "Draw".to_owned(),
        BoardState::Complete(BoardOutcome::WonBy(player)) => {
            format!("Victor: {}", player)
        }
    };

    let switch_button = if *allow_switch {
        let switch_callback = {
            let state = game.clone();
            Callback::from(move |_| {
                allow_switch.set(false);
                let new_player = player.borrow().other();
                *player.borrow_mut() = new_player;

                let state = state.clone();
                let ai_agent = ai_task.clone();
                let id = *counter.borrow();
                let counter = counter.clone();
                spawn_local(async move {
                    let mut game = (*state).clone();
                    let play = ai_agent.run(game.clone()).await;
                    if id == *counter.borrow() {
                        let result = game.mark_tile(play);
                        assert!(!matches!(result, MarkTileResult::NoChange), "move generated by AI should always be valid and should never result in no change.");
                        state.set(game);
                    }
                });
            })
        };

        html! {
            <div class="flex flex-col mx-auto max-w-md text-center gap-3 items-center">
                <button class="font-semibold text-sm bg-primary rounded-full shadow-sm px-4 py-2 max-w-fit" onclick={switch_callback}>{"Make AI Go First"}</button>
            </div>
        }
    } else {
        let restart_callback = {
            let state = game.clone();

            Callback::from(move |_| {
                allow_switch.set(true);
                *player.borrow_mut() = Player::default();
                state.set(Game::new());
                counter.borrow_mut().add_assign(1);
            })
        };

        html! {
            <div class="flex flex-col mx-auto max-w-md text-center gap-3 items-center">
                <button class="font-semibold text-sm bg-primary rounded-full shadow-sm px-4 py-2 max-w-fit" onclick={restart_callback}>{"Restart"}</button>
            </div>
        }
    };

    render_game_div(game, callback, game_state_text, switch_button)
}

#[function_component(LMGameDiv)]
pub(crate) fn lm_game_div() -> Html {
    let game = use_state_eq(Game::new);

    let callback = {
        let state = game.clone();
        Callback::from(move |play| {
            let mut game = (*state).clone();
            if matches!(game.mark_tile(play), MarkTileResult::NoChange) {
                return;
            }
            state.set(game);
        })
    };

    let game_state_text = match game.state {
        BoardState::InProgress => match game.current_player {
            Player::Circle => "Current Player: Circle",
            Player::Cross => "Current Player: Cross",
        }
        .to_owned(),
        BoardState::Complete(BoardOutcome::Draw) => "Draw".to_owned(),
        BoardState::Complete(BoardOutcome::WonBy(player)) => {
            format!("Victor: {}", player)
        }
    };

    let restart_callback = {
        let state = game.clone();
        Callback::from(move |_| {
            state.set(Game::new());
        })
    };

    let restart_button = html! {
        <div class="flex flex-col mx-auto max-w-md text-center gap-3 items-center">
            <button class="font-semibold text-sm bg-primary rounded-full shadow-sm px-4 py-2 max-w-fit" onclick={restart_callback}>{"Restart"}</button>
        </div>
    };

    render_game_div(game, callback, game_state_text, restart_button)
}

fn render_game_div(
    game: UseStateHandle<Game>,
    callback: Callback<(BoardIndex, BoardIndex), ()>,
    game_state_text: String,
    extra: VNode,
) -> Html {
    let children: Vec<Html> = game
        .board
        .enumerate()
        .map(|(index, &region)| {
            let callback = game.is_region_enabled(index).then(|| callback.clone());

            html! {
                <RegionDiv index={index} region={region} callback={callback} />
            }
        })
        .collect();

    html! {
        <div class="flex flex-col mx-auto mt-12 max-w-lg text-center gap-4">
            <div class="grid grid-cols-3 grid-rows-3 aspect-square bg-white gap-0.5">
                { children }
            </div>
            <p>{ game_state_text }</p>
            { extra }
        </div>
    }
}
