use crate::components::RegionDiv;
use common::{
    ai::mct::{make_move, Node},
    BoardIndex, BoardOutcome, BoardState, Game, MarkTileResult, Play, Player,
};
use gloo_console::log;
use tracing::instrument;
use web_time::{Duration, Instant};
use yew::{platform::spawn_local, prelude::*};
use yew_agent::oneshot::{oneshot, use_oneshot_runner};

#[oneshot]
pub fn AITask(game: Game) -> Play {
    let timeout = Instant::now() + Duration::from_secs_f32(5.0);
    let should_terminate = move |node: &Node| {
        if Instant::now() > timeout {
            log!(format!(
                "average score: {:.3} over {} simulations",
                node.score() / node.n_visits() as f32,
                node.n_visits()
            ));
            log!(node
                .children()
                .map(|node| format!(
                    "{:.0} / {} = {:.3}",
                    node.score(),
                    node.n_visits(),
                    node.score() / node.n_visits() as f32
                ))
                .collect::<Vec<_>>());
            true
        } else {
            false
        }
    };

    make_move(game, should_terminate)
}

#[function_component(AIGameDiv)]
#[instrument]
pub(crate) fn ai_game_div() -> Html {
    let game = use_state_eq(Game::new);
    let ai_task = use_oneshot_runner::<AITask>();

    let callback = {
        let state = game.clone();
        Callback::from(move |play| {
            let mut game = (*state).clone();

            // short-circuit if it's the AI's turn.
            if matches!(game.current_player, Player::Cross) {
                return;
            }

            if matches!(game.mark_tile(play), MarkTileResult::NoChange) {
                return;
            }
            state.set(game.clone());

            let state = state.clone();
            let ai_agent = ai_task.clone();
            spawn_local(async move {
                let play = ai_agent.run(game.clone()).await;
                assert!(matches!(game.current_player, Player::Cross));
                let result = game.mark_tile(play);
                assert!(!matches!(result, MarkTileResult::NoChange), "move generated by AI should always be valid and should never result in no change.");
                state.set(game);
            });
        })
    };

    let game_state_text = match game.state {
        BoardState::InProgress => match game.current_player {
            Player::Circle => "Your turn",
            Player::Cross => "AI's turn",
        }
        .to_owned(),
        BoardState::Complete(BoardOutcome::Draw) => "Draw".to_owned(),
        BoardState::Complete(BoardOutcome::WonBy(player)) => {
            format!("Victor: {}", player)
        }
    };

    render_game_div(game, callback, game_state_text)
}

#[function_component(LMGameDiv)]
pub(crate) fn lm_game_div() -> Html {
    let game = use_state_eq(Game::new);

    let callback = {
        let state = game.clone();
        Callback::from(move |play| {
            let mut game = (*state).clone();
            if matches!(game.mark_tile(play), MarkTileResult::NoChange) {
                return;
            }
            state.set(game);
        })
    };

    let game_state_text = match game.state {
        BoardState::InProgress => match game.current_player {
            Player::Circle => "Current Player: Circle",
            Player::Cross => "Current Player: Cross",
        }
        .to_owned(),
        BoardState::Complete(BoardOutcome::Draw) => "Draw".to_owned(),
        BoardState::Complete(BoardOutcome::WonBy(player)) => {
            format!("Victor: {}", player)
        }
    };

    render_game_div(game, callback, game_state_text)
}

fn render_game_div(
    game: UseStateHandle<Game>,
    callback: Callback<(BoardIndex, BoardIndex), ()>,
    game_state_text: String,
) -> Html {
    let children: Vec<Html> = game
        .board
        .enumerate()
        .map(|(index, &region)| {
            let callback = game.is_region_enabled(index).then(|| callback.clone());

            html! {
                <RegionDiv index={index} region={region} callback={callback} />
            }
        })
        .collect();

    html! {
        <div class="flex flex-col mx-auto mt-12 max-w-lg text-center gap-1">
            <div class="grid grid-cols-3 grid-rows-3 aspect-square bg-white gap-0.5">
                { children }
            </div>
            <p>{ game_state_text }</p>
        </div>
    }
}
